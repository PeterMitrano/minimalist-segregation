\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
\overrideIEEEmargins
\usepackage{cite}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{footnote}
\usepackage{cancel}
\usepackage{xfrac}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage[hidelinks]{hyperref}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tikz}
\usepackage{units}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usetikzlibrary{arrows.meta,automata,calc,intersections,positioning}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%     \hypersetup{colorlinks=false}

\newcommand{\myparagraph}[1]{\textbf{#1.}}
\renewcommand{\vec}[1]{\ensuremath{\mathbf{#1}}}

\begin{document}

\title{\LARGE \bf
  A Minimalistic Approach to Segregation\\
  in Robot Swarms}

\author{
    Peter~Mitrano,
    Jordan~Burklund,
    Michael~Giancola,
    Carlo~Pinciroli%
\thanks{$^{1}$ Robotics Engineering, Worcester Polytechnic Institute, MA, USA. Email: {\sf \{cpinciroli,jupatel\}@wpi.edu}}%
}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
  We present a decentralized algorithm to achieve segregation into an arbitrary
  number of groups with swarms of autonomous robots. The distinguishing feature
  of our approach is in the minimalistic assumptions on which it is
  based. Specifically, we assume that (i) Each robot is equipped with a ternary
  sensor capable of detecting the presence of a single nearby robot, and, if
  that robot is present, whether or not it belongs to the same group as the
  sensing robot; (ii) The robots move according to a differential drive model;
  and (iii) The structure of the control system is purely reactive, and it maps
  directly the sensor readings to the wheel speeds with no computation beyond a
  simple `if' statement. We present a thorough analysis of the parameter space
  that enables this behavior to emerge, along with conditions for guaranteed
  convergence and a study of non-ideal aspects in the robot design.
\end{abstract}

% \begin{IEEEkeywords}
%   TBD
% \end{IEEEkeywords}

\section{Introduction}

% Group formation
% segregation as group formation
% Spatially organizing behaviors
%   of objects
%   of robots
%     aggregation
%     circles
% On the importance of minimalism
% Minimalistic segregation
Group formation is one of the most fundamental mechanisms a robot swarm must
exhibit~\cite{Brambilla2013}. Group formation can occur in several forms to
satisfy different requirements. Segregation is a particular type of group
formation in which the focus is on creating local aggregates of robots that
share a common property. Segregation can be seen as a precursor to object
sorting, task allocation, or self-assembly. For example, swarms may need to
split into arbitrary groups to diffuse and search different areas, or segregate
by skill or capability in order to form useful heterogeneous teams.

Segregation is an example of the broader class of spatially organizing
behaviors, whose purpose is to impose a structure in the environment (e.g.,
object clustering~\cite{gauci_clustering_2014}, collective
construction~\cite{Bolger2010}) or in the distribution of the robot (e.g.,
aggregation~\cite{shlyakhov_survey_2017}, pattern
formation~\cite{Pinciroli:DARS2016}, self-assembly~\cite{gross2008self}).

A recent line of research in spatially organizing behaviors focuses the
\emph{minimal} assumptions a swarm of robot must fulfill in order to perform the
task. Johnson and Brown~\cite{johnson_evolving_2016} and Brown \emph{et
  al.}~\cite{brown_discovery_2018} characterized the set of possible behaviors
that can be obtained using primordial control strategies based on a simple
`if/then/else' structure, binary sensors, and differential-drive robots. Gauci
\emph{et al.} provided the specific conditions for the emergence of
aggregation~\cite{gauci_evolving_2014} and object
clustering~\cite{gauci_clustering_2014}, while St.-Onge \emph{et
  al.}~\cite{StOnge:IROS2018} studied the emergence of circular
formations. While more efficient control strategies have been proposed to
achieve these behaviors, studying the minimal assumptions for their emergence is
an important step towards principled `swarm engineering' practices. In addition,
these minimal behaviors might offer last-resort solutions in case of sensor
failures in remote environments such as in planetary exploration missions.

This paper furthers this line of inquiry by studying the minimal assumptions for
$N$-class segregation to emerge from local, decentralized interactions among
robots. The term `$N$-class' refers to the creation of $N$ spatially distinct
groups. We show that, for segregation to emerge, it is sufficient to equip an
`if/then/else', differential drive robot with a \emph{ternary} sensor. This
sensor detects the presence of a robot in range; when a robot is detected, the
sensor can distinguish whether it is a \emph{kin}, i.e., it belongs to the same
group as the sensing robot, or a \emph{non-kin}, i.e., it belongs to a different
group. When multiple robots are in range, the sensor returns information on the
closest one of them.

The main contributions of this paper are \emph{(i)} A study of the parameter
space that enables the emergence of $N$-class segregation; \emph{(ii)} A study
of why convergence is guaranteed for the best parameter choice found; and
\emph{(iii)} An analysis of the robustness of the algorithm to non-idealities in
the robot design.

\section{Related Work}
Segregation is a common behavior in nature, and it can be observed across
scales. For example, cell segregation is a basic building block of embryogeneis
in tissue generation processes~\cite{batlle_molecular_2012,Steinberg1963}; while
social insects, such as ants, organize their brood into ring-like
structures~\cite{Franks1992}.

In robotics, segregation is a problem that has not received considerable
attention. The main methods that have been proposed so far are based on some
variation of the artificial potential approach~\cite{Spears2004}, which assumes
that the robots can detect each other and estimate relative distance vectors.

Gro\ss~\emph{et al.}~\cite{gross_segregation_2009} proposed an
algorithm inspired by the Brazil Nut effect, in which the robots form regular
layers simulating gravity by sharing a common direction. This work was later
extended to work on e-pucks robots~\cite{Chen2012}. To simulate gravity, this
approach requires the robots to share a common target vector, which can be
obtained through centralized controllers or a distributed consensus algorithm.

Kumar \emph{et al.}~\cite{kumar_segregation_2010} introduced the concept of
``differential potential'', whereby two robots experience a different artificial
potential depending on their being part of the same class or not. The
convergence of this approach is guaranteed for two classes, but when more
classes are employed local minima prevent segregation from emerging.

Santos \emph{et al.}~\cite{santos_segregation_2014} took inspiration
from~\cite{kumar_segregation_2010} to devise an approach based on the
Differential Adhesion Hypothesis, which states that kin cells tend to adhere
stronger than non-kin cells. Hower, one limitation is the assumption
that the robots have global knowledge about the positions of other robots.

To the best of our knowledge, this paper is the first to propose a segregation
algorithm that is not based on global information nor on communication and
sensing of multiple neighbors.

% Santos [20] [21]
% - segregation with velocity obstacles
% - 



% In nature, we can find several examples of segregation. Segregation occurs in cells during embryogenesis
% \cite{batlle_molecular_2012}, and segregation of objects can be found in ants
% who sort their brood \cite{santos_segregation_2014}. These examples motivate the
% study of simple controllers for segregation, but our main motivation comes from
% the broader question of whether a complex behavior like $N$-class segregation
% can be achieved with a simple robot and controller.

% Segregation of robots has received little attention in swarm robotics, however
% many researchers have focused on sorting of objects
% \cite{vardy_accelerated_2012} \cite{holland_collective_1998}
% \cite{tao_wang_collective_2004} \cite{holland_stigmergy_1999}. Santos et
% al. shares our objective, however they assume that each class has the same
% number of robots and that each robot knows the position of all other robots
% \cite{santos_segregation_2014}. In contrast, we adhere to the
% \texttt{if/elseif/else} controller architecture with a simple ternary sensor. In
% \cite{gross_segregation_2009}, Gro\ss\ et al. also explore segregation robots
% based on local interactions inspired by gravity, however they require a
% centralized broadcast or a consensus algorithm to agree on the source or
% direction of gravity.

  %   We make no claims that the controllers studied here are the most practical engineering solutions, but rather that they are an example of how complex behavior can emerge from simple rules. The advantages of simple robots is that they are inexpensive, easier to implement. It is also easy to understand and construct proofs about the behavior of these simple robots and their controllers.

  % We also provide analysis of a specific emergent behaviors that allows the segregation to work. This analysis, while specific to the segregation behavior and controllers we found, is an example of how to make provable claims about emergent behavior of simple controllers. This is important because having guarantees on swarm behavior and well understand limitations allows one to make an informed decision about whether to deploy the controller in untested environments. If swarm robotics are to actually be used in disaster relief, as is so often proposed, it's important to know the conditions under which certain behavior is guaranteed. In these scenarios, using the simplistic robot and controllers may actually be advantageous.

  % \subsection{Aggregation and Segregation}

  %   Aggregation is defined as having all robots in the swarm collect at a particular location in a distributed manner. Many swarm aggregation controllers require robots to compute bearing and distance to other robots, to sense gradients in the environment, or to otherwise communicate information. However, implementing these communication systems is difficult in practice, so methods that do not require communication or complex sensing are desirable. In \cite{gauci_self-organized_2014}, Guaci et al propose a new class of controllers that require no computation.

  %  Gasparri et al. instead develop an aggregation controller which enables robots to respond to guidance commands -- i.e., a human using hand gestures to indicate which direction the swarm should move \cite{gasparri_swarm_2012}. They show that swarms running their controller are able to follow guidance commands and stay aggregated without colliding. A simpler controller is used by Bahgeci and Sahin \cite{bahgeci_evolving_2005}, where robots are equipped with IR distance sensors surrounding the robot, 4 microphones, and an omni-directional speaker. The controller is a linear combination of the IR sensor values and the intensity values of the microphones. The authors show that a genetic algorithm is able to find weights for the controller such that robots aggregate. In \cite{ando_distributed_1999}, Ando et al. present an aggregation controller with very limited sensing and no memory, but allows the robots to perform computations to determine their next position. They prove that their controller is correct in theory, then run the controller in simulation.

  %   Finally, Gauci et al. consider a binary sensor that maps directly to wheel velocities \cite{gauci_self-organized_2014}. The authors demonstrate robust aggregation despite these limitations, and they also prove formally that aggregation is guaranteed and find theoretical bounds on aggregation time in simple situations. Gauci et al. also perform object aggregation, as opposed to robot aggregation, with the same restrictions on sensing and control \cite{gauci_clustering_2014}.


  %   %By analysing all the various controllers that we found which perform segregation, we can say that they can all be described by simple rules based on the wheel speeds. These rules are therefore also useful because they tell us something fundemental about the segregation behavior.

  % \subsection{Oblivious Robots}

  %   Oblivious robots is a These robots were originally proposed by Gauci et al., and have been extended to other tasks and been modified in many ways by other researchers.

  %   Kernbach et al. propose an aggregation controller inspired by bees clustering in an optimal temperature location \cite{kernbach_re-embodiment_2009}. In their method, robots are only able to distinguish between collisions between another robot or a wall, can only sense the intensity of a light source when they have collided, and do not communicate information. Although the robots have limited sensing and communication capabilities, the authors show that robots can aggregate to an optimal light intensity location, and that the time to converge to the optimal location improves with increasing number of robots in the environment.

  %   Oblivious robots have also been shown to aggregate around a specific object, circle in a ring around an object, and forage for obstacles \cite{johnson_evolving_2016}. In this work, the show one can construct simple cost functions to guide the evolution of controllers to perform new, yet interesting tasks. However, they also report that in attempting to evolve a controller to rendezvous the robots around an object, they accidentally and consistently evolved a controller where the robots circled around the target object. They achieved rendezvous by initializing the controller at generation zero to the controller found in \cite{gauci_self-organized_2014} for simple aggregation.

\section{Methodology}

\subsection{Problem Formulation}

\newcommand{\vL}{\ensuremath{v_{\text{left}}}}
\newcommand{\vR}{\ensuremath{v_{\text{right}}}}
\newcommand{\vaL}{\ensuremath{V_{\text{left}}}}
\newcommand{\vaR}{\ensuremath{V_{\text{right}}}}
\newcommand{\VM}{\ensuremath{V_{\text{max}}}}
\myparagraph{Motion model}
We consider a set of robots executing the same controller in a two-dimensional,
obstacle-free environment. The robots are equipped with two wheels for which
$[\vL,\vR]$ denote their \emph{normalized} linear speeds. By `normalized' we
mean that the speed values are in the range $[-1, 1]$. Using normalized speeds
allows us to reason in a general way over the specific speeds attainable by any
robot. To transform from normalized speeds $[\vL,\vR]$ into actual speeds
$[\vaL,\vaR]$, we introduce a parameter $\VM$ that denotes the maximum linear
speed possible with a specific robot and define
\begin{align}
  \vaL &= \VM \vL\\
  \vaR &= \VM \vR.
\end{align}
The robots' motion is modeled by the well-known differential-drive
equations~\cite{Dudek2010}
\begin{equation}
  \label{eq:diffdrive}
  \begin{aligned}
    x(t)      &=  \frac{l}{2}\frac{\vaR+\vaL}{\vaR-\vaL}\sin\left(\frac{\vaR-\vaL}{l}t\right)\\
    y(t)      &= -\frac{l}{2}\frac{\vaR+\vaL}{\vaR-\vaL}\cos\left(\frac{\vaR-\vaL}{l}t\right)\\
    \theta(t) &=  \frac{\vaR-\vaL}{l}t
  \end{aligned}
\end{equation}
where $t$ is time, $[\,x\;y\;\theta\,]^T$ is the pose of the robot, and $l$ is
the distance between the wheels.

\newcommand{\vPN}[2]{\ensuremath{v_{\text{#1}}}^{S=#2}}
\newcommand{\robot}[2]{%
  \filldraw[draw=#2,fill=#2!20] (#1) circle(5mm);
  \draw[draw=#2,->,-Stealth,rotate around={0:(#1)}] (#1) -- +(5mm,0);
  \fill[fill=gray!20] ($(#1)+(5mm,0)$) -- +( 45:1cm) -- +(-45:1cm) -- cycle;%
  \fill[fill=#2] ($(#1)+(5mm,0)$) circle (1mm);%
}
\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \coordinate (s0) at (0  cm,0cm);
    \coordinate (s1) at (1.5cm,0cm);
    \coordinate (s2) at (3  cm,0cm);
    \robot{s0}{red};
    \robot{s1}{red};
    \robot{s2}{blue};
    \node[below=of s0]{\texttt{S=1}};
    \node[below=of s1]{\texttt{S=2}};
    \node[below=of s2]{\texttt{S=0}};
  \end{tikzpicture}
  \caption{A diagram of the ternary sensor in which classes are depicted
    as colors. The left red robot detects a kin robot, so its sensor
    returns 1. The middle red robot detects a blue robot, so its sensor
    returns 2. The right robot detects no robot, so its sensor returns
    0.}
  \label{fig:sensor}
\end{figure}
\begin{algorithm}[t]
  \begin{algorithmic}
    \If {$S=0$} \State set wheel speeds to $\vPN{left}{0}$, $\vPN{right}{0}$
    \ElsIf {$S=1$} \State set wheel speeds to $\vPN{left}{1}$, $\vPN{right}{1}$
    \Else \State set wheel speeds to $\vPN{left}{2}$, $\vPN{right}{2}$
    \EndIf
  \end{algorithmic}
  \caption{The segregation control algorithm.}
  \label{alg:controller}
\end{algorithm}

\myparagraph{Sensor model}
The robots are also equipped with a ternary sensor that is able to detect the
presence of nearby robots and their ``kinness''. Two robots are \emph{kin} if
they belong to the same class (denoted by color in our experiments); they are
\emph{non-kin} otherwise. The sensor is assumed to have infinite range (we
consider non-infinite range in Sec.~\ref{section:beam_range}). As depicted in
Fig.~\ref{fig:sensor}, the sensor returns a reading $S=0$ when no robot is
detected, $S=1$ when a kin robot is detected, and $S=2$ when a non-kin robot is
detected. We allow for any number of classes, but the sensor need not
distinguish between different non-kin classes---it only detects whether a nearby
robot belongs to the same class or not.

\myparagraph{Control logic}
The control logic followed by the robots is formalized in
Alg.~\ref{alg:controller}. It is a simple `if/then/else' structure, which maps
the sensor readings $S$ directly into normalized wheel speeds $[\,\vL\;\vR\,]$. The
latter are the parameters whose value we intend to study, and they can be
encoded as a six-dimensional vector
$$
[\,
\vPN{left}{0}\;
\vPN{right}{0}\;
\vPN{left}{1}\;
\vPN{right}{1}\;
\vPN{left}{2}\;
\vPN{right}{2}\;
\,].
$$

\myparagraph{Objective}
The objective of our study is to find the values of the speed parameters for
which the robots group into clusters, such that all the robots of the same class
are packed into one cluster with no non-kin robots.

\subsection{Simulation Environment and Robots}

\myparagraph{Simulation platform} We utilized the ARGoS multi-robot
simulator~\cite{pinciroli_argos:_2012} to search for controller parameters and
evaluate them. ARGoS offers accurate models for several differential-drive
robots, such as the foot-bot~\cite{Bonani2010}, the Khepera
IV\footnote{https://www.k-team.com/khepera-iv}, and the
Kilobot~\cite{Rubenstein2012}.

\myparagraph{Robot platform}
For the simulated experiments we opted to use the foot-bot, because of the
possibility to utilize its range-and-bearing communication system as a base for
the ternary sensor. The advantage of using the range-and-bearing system is that
its model is simple and, as a consequence, a large number of simulations could
be completed in a short time. The range-and-bearing system allows two robots to
exchange messages when they are in direct line-of-sight; upon receiving a
message, a robot can also estimate the relative position of the sender. This
sensor, in principle, receives messages from all the nearby robots. To simulate
the ternary sensor, our robot controller kept the message of the closest
robot. The message payload was an integer that encoded the id of the group to
which the sender belonged. The range-and-bearing sensor is simulated through ray
casting. This allowed us to assume that the sensor reading is infinitely thin, a
choice that simplifies the mathematical analysis presented in
Sec.~\ref{sec:analysis}. However, in practical applications, the sensor can be
expected to cast a cone-shaped sensory range with non-zero aperture angle. We
explore the performance effect of various angles in
Sec.~\ref{sec:aperture_angle}.

\subsection{Grid Search}
\label{sec:gridsearch}
  
\myparagraph{Trial setup}
In order to exhaustively search the space of possible controllers, we conducted
a grid search of the 6-dimensional parameter space. Due to limited computational
resources, we were only able to search with a resolution of $7$ values per
parameter, which means in total we evaluated $7^6=117,649$ parameter sets. For
each parameter set, we tested 38 different initial configurations, with 100
simulated seconds for each trial. These initial configurations consisted of
uniformly random placement, clusters, and lines of robots distributed throughout
the environment. We chose to include some structured configurations (clusters
and lines) because we discovered that they affected significantly the
performance with respect to uniform random configurations. Hence, by explicitly
evaluating diverse initial configurations, we could better estimate the best
parameter values in the general case.

\myparagraph{Clusters}
To define our cost function, we first establish the notion of
`cluster'. Denoting with $r$ the radius of the body of a robot, and defining
$\vec{p}_i(t) = [x_i(t)\;y_i(t)]$, we consider any two robots to be
\emph{connected} if
$$
\lVert\vec{p}_i(t) - \vec{p}_j(t)\rVert \le 2r + \epsilon \qquad (i \ne j, \epsilon \in \mathbb{R}^+).
$$
In our experiments, we set $\epsilon = \SI{5}{\centi\meter}$.  A
\emph{cluster} can be intuitively defined as an `island' of connected
robots, and it can be found with a depth-first search across the
robots. Since we are interested in segregating the robots in $N$
classes, the final result of a trial is expected to be a set of $N$
distinct clusters \emph{composed of kin robots}. Hence, we define a
cluster as an island of connected kin robots.

\myparagraph{Cost function}
To measure the difference between the ideal, perfectly segregated result and any
configuration achieved by the robots over time, we first calculate, for every
class $i$, the largest cluster $c_i(t)$ formed by robots of class $i$.  Since,
in principle, different classes might involve different numbers of robots, in
our cost function we employ the ratio
$$
\gamma_i(t) = \frac{c_i(t)}{C_i}
$$
where $C_i$ is the number of robots that belongs to class $i$. Our cost function
is then
\begin{equation}
  \label{eq:cost_function}
  c_{\text{total}} =  \frac{1}{n}\sum_{i=1}^N\sum_{t=0}^{T-1} -t \gamma_i(t)
\end{equation}
in which we denote the total trial time (100 seconds) with $T$. Since
$\gamma_i(t)$ is lowest when no robots in a specific class are connected and $1$
when they are all connected, the negative sign assigns larger clusters a lower
cost. The effect of multiplying $\gamma_i(t)$ by $t$ is to highlight the
emergence of clusters as the trial time proceeds: we cannot expect large
clusters to be present at the beginning of a trial, but good parameter settings
should grow (and maintain) clusters over time. In our experiments, we found that
$c_{\text{total}}(t)$ correctly assigns cost in most scenarios, thus fitting
well our analysis purposes. However, this cost function considers a straight
line of robots to be a cluster, and as such it might not be ideal for scenarios
in which the clusters are required to be tight.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.32\linewidth]{./images/0_1_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/2_3_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/4_5_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/0_3_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/0_5_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/1_4_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/1_2_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/3_4_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/2_5_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/0_4_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/1_5_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/0_2_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/1_3_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/2_4_grid_img}
  \includegraphics[width=0.32\linewidth]{./images/3_5_grid_img}
  \caption{Heatmaps that relate relevant pairs of wheel speeds.}
  \label{fig:gridsearch}
\end{figure}

\section{The Emergent Behavior}
\myparagraph{Visualizing grid search}
The results of grid search are reported in Fig.~\ref{fig:gridsearch}. Because
the search space is six-dimensional, we chose to visualize it by plotting every
pair of parameters against each other. For example, we consider how the cost
changes as $\vPN{left}{0}$ and $\vPN{right}{0}$ change. As an example of reading
these plots, we can tell from the plot of $\vPN{left}{1}$ and $\vPN{right}{1}$
that there were no good controllers where the left and right wheel speeds were
equal and negative (dark squares in the upper left), and that the best
controllers had slightly unequal values close to 1 (lightest squares in the
bottom left). These plots also convey the presence of sharp discontinuities
where performance changes dramatically.

\myparagraph{The emergent behavior}
After running the grid search, the parameters with the lowest cost across all 38
configurations was
\begin{equation}
\label{eq:controller}
[1, -\sfrac{2}{3}, \sfrac{1}{3}, 1, 1, 0].
\tag{C}
\end{equation}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\linewidth]{./images/rings_example.png}
  \caption{The segregation behavior found by grid search consists in the
    formation of homogeneous rings or spiraling structures that keep spinning
    over time. The rings tend to grow over time, disband, and reform.}
  \label{fig:rings}
\end{figure}
The resulting behavior is for a robot to turn away from kin, but turn the
opposite way when the robot sees nothing or non-kin. This behavior amounts to
robots zig-zagging in a line towards their kin. As discussed
in~\cite{StOnge:IROS2018}, when multiple robots execute this zig-zag behavior,
spinning rings are formed. The remarkable aspect, in our case, is that spinning
rings of \emph{kin} robots emerge, eventually segregating the swarm in
homogeneous groups. An example of this phenomenon as observed in simulated
experiments is reported in Fig.~\ref{fig:rings}. We also noted that, rarely, the
robots form spinning spiral shapes, which can also be seen in
Fig.~\ref{fig:rings}.

\myparagraph{Interesting phenomena}
It is important to note that, although we originally hoped that segregated
clusters would be tightly packed, in our grid search we never found any
parameter setting that was capable of creating tight clusters. In addition, we
observed that the spinning rings formed by the robots tended to expand over
time, disband into smaller structures, and eventually reappear. In addition, if
a ring is disturbed by non-kin robots passing through it, the ring is disrupted
but it eventually reforms. The growing and self-repairing dynamics is compatible
with the findings in the work of St.-Onge \emph{et al.}~\cite{StOnge:IROS2018},
in which ring formation is decomposed in four simpler behavioral traits:
scouting, chaining, looping, and merging. This segregation behavior follows the
same phases, and it constitutes a further example of structured space-time
coordination arising from minimalistic assumptions on the capabilities of the
robot. To better appreciate the dynamics of this behavior, we invite the
interested reader to watch the videos at
\href{https://www.youtube.com/playlist?list=PL9HqYJ1IkIKVX9EsT5BY9LnBsBPTjc5bB}{https://goo.gl/z8UAuB}.

\section{Behavior Analysis}
\label{sec:analysis}
Using the parameter settings~\eqref{eq:controller} as a basis, we now analyze
the emerging behavior with the purpose of explaining how and why it emerges. In
particular, we discuss the conditions under which segregation is guaranteed.
\newcommand{\ICC}{\ensuremath{\text{ICC}}}

In the proofs, we employ the well-known equations that govern the instantaneous
radius of curvature $R$ and rotation speed $\omega$ of the path followed a
differential-drive robot~\cite{Dudek2010}:
\begin{equation}
  \label{eq:Ricc}
  \begin{aligned}
    R &= \frac{l}{2}\frac{\vaR + \vaL}{\vaR - \vaL} = \frac{l}{2}\frac{\vR + \vL}{\vR - \vL}\\
    \omega &= \frac{\vaR - \vaL}{l} = \frac{\VM(\vR - \vL)}{l}.
  \end{aligned}
\end{equation}

\begin{theorem}[Scouting]
  When a robot $i$ does not detect a kin, it turns clockwise until it finds one.
\end{theorem}
\begin{proof}
  The proof derives from the observation of the speeds in
  \eqref{eq:controller}. When $S=0$ (no robot detected) and $S=2$ (non-kin
  detected), the left wheel speed is larger than the right one, producing a
  circular clockwise motion. Conversely, when $S=1$ (a kin is detected), the
  right wheel speed is larger than the left one, and the robot turns
  counterclockwise.
\end{proof}

\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    % Coordinates
    \coordinate(Pi)  at (0,0);
    \coordinate(Pj)  at ($(Pi)+(5cm,0cm)$);
    \coordinate(ICC) at ($(Pi)+(0cm,2cm)$);
    \coordinate(Qi)  at ($(Pj)!5cm!-21.812:(ICC)$);
    % Label R
    \draw (ICC) -- (Pi) node[left,midway]{$R$};
    % Label delta
    \draw (Pi) -- (Pj) node[below,midway]{$D$};
    % Label theta
    \draw ($(ICC)-(0,1cm)$) arc (-90:46.376:1cm) node[pos=0.75,below right]{$\bar{\theta}$};
    % Qi to ICC
    \draw (Qi) -- (ICC);
    % Pj to ICC
    \draw (Pj) -- (ICC);
    % Pj to Qi
    \draw (Pj) -- (Qi);
    % Trajectory and ICC
    \draw[dashed,very thick,green!60!black,-{Stealth[]},shorten >=2mm] ($(ICC)-(0,2cm)$) arc (-90:46.376:2cm);
    \fill (ICC) circle (1mm);
    \node[left] at (ICC) {$\ICC$};
    % Blue robot
    \draw[very thick,blue] (Pi) circle (5mm);
    \fill[blue] (Pi) circle (1mm);
    \node[below] at (Pi) {$\vec{p}_i$};
    % Qi
    \fill[blue] (Qi) circle (1mm);
    \node[right] at (Qi) {$\vec{q}_i$};
    % Red robot
    \draw[very thick,red] ($(Pj)-(0,5mm)$) circle (5mm);
    \fill[red] (Pj) circle (1mm);
    \node[below] at (Pj) {$\vec{p}_j$};
  \end{tikzpicture}
  \caption{A diagram for the geometry of motion towards kin robots. The red
    circle ($\vec{p}_j$) depicts the detected kin neighbor; the blue circle
    indicates the robot whose motion is being modeled ($\vec{p}_i$); the dashed
    green arc is the path followed by the robot, up to the limit point
    $\vec{q}_i$. Beyond the latter point, the blue robot ceases to move closer
    to the red robot.}
  \label{fig:movetokin}
\end{figure}
\begin{lemma}[Motion towards kin when kin detected]
  A robot moves towards a kin robot if
  \begin{equation}
    \label{eq:movetokin}
    \VM\Delta t \le 3l\tan^{-1}\left[\frac{\sqrt{3}r}{l}\right].
    \tag{S1}
  \end{equation}
\end{lemma}
\begin{proof}
  When a robot encounters a kin, it picks the speeds
  $\vPN{left}{1} = \sfrac{1}{3}$ and $\vPN{right}{1} = 1$. This corresponds to a
  path that arcs counterclockwise, as reported in the diagram of
  Fig.~\ref{fig:movetokin}. We indicate the position of the moving robot as
  $\vec{p}_i$ and the position of the kin as $\vec{p}_j$. For robot $i$ to move
  towards $j$, its trajectory path must be an arc that does not move past a
  limit point $\vec{q}_i$ because, beyond this point, the distance between $i$
  and $j$ would increase. We can express this condition as
  $|\omega|\Delta t\le \bar{\theta}$, where $\bar{\theta}$ is the angle of the arc
  connecting $\vec{p}_i$ and $\vec{q}_i$.

  Reasoning on the triangle formed by $\vec{p}_i$, $\vec{p}_j$ and the $\ICC$,
  we can calculate
  \begin{equation}
    \label{eq:theta2}
    \frac{\bar{\theta}}{2} = \tan^{-1}\frac{D}{|R|}
  \end{equation}
  where we defined $D = \lVert\vec{p}_i - \vec{p}_j\rVert$. The rhs of this
  inequality monotonically increases with $D$, hence to find the most strict
  condition we need to consider the smallest value of $D$ possible. This value
  corresponds to the situation in which $i$ and $j$ are tangent to each other;
  in this case, $D=\sqrt{3}r$, where $r$ indicates the robot radius (assumed
  identical for both robots). Using \eqref{eq:Ricc} with the values of
  $\vPN{left}{1}$ and $\vPN{right}{1}$, we obtain:
  \begin{align*}
    R &= \frac{l}{2}\frac{1+\sfrac{1}{3}}{1-\sfrac{1}{3}} = l\\
    \omega &= \frac{\VM(1-\sfrac{1}{3})}{l} = \frac{2}{3}\frac{\VM}{l}.
  \end{align*}
  Plugging these expressions in \eqref{eq:theta2}, we obtain the statement.
\end{proof}

\begin{lemma}[Motion towards kin when nothing detected]
  Assume that a robot $i$ saw a kin $j$ at time $t-1$, has performed one step
  with $\vPN{left}{1}$ and $\vPN{right}{1}$, and at time $t$ it detects no robot.
  Robot $i$ moves towards the kin robot if
  \begin{equation}
    \label{eq:movetonone}
    \VM\Delta t \le \frac{6}{5}l\tan^{-1}\left[\frac{10\sqrt{3}r}{l}\right].
    \tag{S0}
  \end{equation}
\end{lemma}
\begin{proof}
  This proof follows the same reasoning as in Lemma 1 with the wheel speeds
  $\vPN{left}{0} = 1$ and $\vPN{right}{0} = -\sfrac{2}{3}$.
\end{proof}

\begin{lemma}[Motion towards kin when non-kin detected]
  Assume that a robot $i$ saw a kin $j$ at time $t-1$, has performed one step
  with $\vPN{left}{1}$ and $\vPN{right}{1}$, and at time $t$ it detects a non-kin.
  Robot $i$ moves towards the kin robot if
  \begin{equation}
    \label{eq:movetononkin}
    \VM\Delta t \le 2l\tan^{-1}\left[\frac{2\sqrt{3}r}{l}\right].
    \tag{S2}
  \end{equation}
\end{lemma}
\begin{proof}
  This proof follows the same reasoning as in Lemma 1 with the wheel speeds
  $\vPN{left}{2} = 1$ and $\vPN{right}{2} = 0$.
\end{proof}

\begin{figure}[t]
  \centering
  \includegraphics{condition}
  \caption{A graphical proof that \eqref{eq:movetonone} is the strictest
    condition. The graph relates the length of the interwheel distance to the
    value of the conditions, for a constant value of the robot body radius.}.
  \label{fig:conditions}
\end{figure}
\begin{theorem}[Chaining]
  A robot $i$ eventually follows a kin $j$ if \eqref{eq:movetonone} holds.
\end{theorem}
\begin{proof}
  Because of Theorem 1, a robot that has not detected a kin rotates clockwise
  until it finds one. After this, the robot turns counterclockwise and, if
  \eqref{eq:movetokin} holds, it steps closer to the kin. When the robot cannot
  detect the kin anymore it turns counterclockwise. If both
  \eqref{eq:movetonone} and \eqref{eq:movetononkin} hold, then it is guaranteed
  robot $i$ moves closer to the kin. Eventually robot $i$ will see the kin
  again, and the cycle continues. This reasoning can be repeated for any pair of
  robots, and a chain self-sustains if the three conditions are satisfied at the
  same time. This occurs when the strictest among them holds. As shown
  graphically in Fig.~\ref{fig:conditions}, the strictest condition is
  \eqref{eq:movetonone}.
\end{proof}

\begin{theorem}[Looping]
  A chain of kin robots eventually forms a loop.
\end{theorem}
\begin{proof}
  When a chain is formed, the robot in front either detects a kin, in which case
  it follows it (thus growing the chain); or it does not detect a kin, in which
  case it moves clockwise until it detects one of the kin robots that follow it
  in the chain. Since every robot behind the front robot performs the chaining
  behavior, this results in the chain looping on itself until the tail is
  reached and the loop is closed.
\end{proof}

% In Sec.~\ref{sec:analysiskin} we focus on the case in which a kin robot
% aggregates with a static kin or ring of kin. We then show in
% Sec.~\ref{sec:analysisnonkin} that a robot also aggregates to
% non-kin. However, we show that aggregation to kin is always faster than
% aggregation to non-kin, thus resulting in emerging segregation. In our analysis,
% we assume that the controllers are synchronized in time, i.e., every robot's
% motion is executed for the same $\Delta t$ starting at the same instant.

% The instantaneous center of curvature ($\ICC$) is~\cite{Dudek2010}
% \begin{equation*}
%   \ICC =
%   \begin{bmatrix}
%     x - R\sin\theta\\
%     y + R\cos\theta
%   \end{bmatrix}
% \end{equation*}
% and \eqref{eq:diffdrive} can be rewritten as
% \begin{equation}
%   \label{eq:diffdrive2}
%   \begin{split}
%     \begin{bmatrix}
%       x'\\
%       y'\\
%       \theta'
%     \end{bmatrix}
%     =
%     &\begin{bmatrix}
%       \cos(\omega\Delta t) & -\sin(\omega\Delta t) & 0\\
%       \sin(\omega\Delta t) \cos(\omega\Delta t) & 0\\
%       0 & 0 & 1
%     \end{bmatrix}
%     \times\\
%     &
%     \begin{bmatrix}
%       x - \ICC_x\\
%       y - \ICC_y\\
%       \theta
%     \end{bmatrix}
%     +
%     \begin{bmatrix}
%       \ICC_x\\
%       \ICC_y\\
%       \omega\Delta t
%     \end{bmatrix}.
%   \end{split}
% \end{equation}

% \subsection{Motion towards Kin}
% \label{sec:analysiskin}

% \begin{figure}[t]
%   \centering
%   \begin{tikzpicture}[scale=25.0]
%     \draw[->] (0.15,0) -- (0.23,0);
%     \node at (0.22,.01) {x};
%     \draw[->] (0.15,0) -- (0.15,0.07);
%     \node at (.14,0.07) {y};

%     % c_i
%     \filldraw (0,0.053) circle (.002);
%     \draw[blue, dashed] (0,0.053) circle (0.053);

%     % p_i
%     \filldraw (0,-0.0) circle (.002);
%     \draw[blue] (0,-.0) circle (0.035);
%     \node at (-0.02,.044) {$R_\text{kin}$};
%     \draw[dashed] (0,0.054) -- (0,0.0);
%     \draw (-0.014,0.011) -- (-.002,.002);
%     \node at (-0.020,0.014) {$\vec{p}_i$};

%     % delta
%     \draw[blue] (0,.0) -- (.15,.0);
%     \node at (0.08, 0.008) {$\delta$};

%     % p'_i
%     \filldraw (0.0231,0.005) circle (.002);
%     \draw (0.027, 0.003) -- (.04,-0.010);
%     \draw[blue] (0.0231,0.005) circle (0.035);
%     \draw[dashed] (0,0.053) -- (0.0231,0.005);
%     \node at (0.045,-.010) {$\vec{p}'_i$};

%     % p_j
%     \draw[dashed, red] (0.15, -0.035) circle (0.035);
%     \filldraw (0.15, 0.0) circle (.002);
%     \node at (0.159, 0.010) {$\vec{p}_j$};

%     % theta
%     \draw (0,.0265) arc [radius=.03, start angle=-90, end angle=-69];
%     \node at (.035,.047) {$\theta_\text{kin}$};
%     \draw (.005, .020) -- (.027,.042);

%   \end{tikzpicture}
%   \caption{A diagram depicting the geometry of a robot (in blue) aggregating to
%     a kin robot (in red).  The configuration of a robot aggregating to another
%     kin. $R_{\text{kin}}$ is the radius of the robot's path around the
%     instantaneous center of curvature.}
%   \label{fig:kin_aggregation}
% \end{figure}
% Consider an isolated robot $i$ which has sensed another kin robot $j$. This
% scenario is depicted in Fig.~\ref{fig:kin_aggregation}, in which the blue
% circles denote robot $i$ and the red circle is robot $j$.

% To characterize kin clustering, we consider the case in which robot $j$ is
% static. We define the conditions under which robot $i$ is guaranteed to move
% closer to the point $\vec{p}_j$ where the sensor beam of $i$ meets the kin robot
% $j$. Robot $i$ starts its motion at $\vec{p}_i$ with sensor reading $S=1$. The
% robot then sets the wheel speeds $\vPN{left}{1} = \sfrac{1}{3}$ and
% $\vPN{right}{1} = 1$, which results in a path that arcs counterclockwise with
% radius $R$ and ends at position $\vec{p}'_i$ at time $t + \Delta t$. For robot
% $i$ to be closer to entity $j$ after this motion, it must hold that
% \begin{equation*}
%   \lVert \vec{p}'_i - \vec{p}_j \rVert < \lVert \vec{p}_i - \vec{p}_j \rVert.
% \end{equation*}
% To simplify our analysis, and without loss of generality, we set
% $\vec{p}_j = \vec{0}$ and define the x axis along the vector that connects
% $\vec{p}_i$ to the origin, obtaining
% \begin{equation}
%   \label{eq:generic_agg}
%   \lVert \vec{p}'_i \rVert < \lVert \vec{p}_i \rVert.
% \end{equation}

% Expanding \eqref{eq:generic_agg}, we can derive the following condition for
% aggregation to be guaranteed.

% \begin{theorem}
%   \label{thm:aggregation_with_kin}
%   An isolated robot radius $r$ and interwheel distance $l$ aggregates with a kin
%   entity if
%   \begin{equation}
%     \label{eq:aggwithkin}
%     (3 - 2\sqrt{3})r \ge 2l(l-1).
%   \end{equation}
% \end{theorem}

% \begin{proof}
%   To simplify our notation, let $\delta = \lVert\vec{p}_i\rVert$. Then, because
%   of the way the axes are defined, $\vec{p}_i = [\,-\delta\;0\,]^T$. To prove
%   \eqref{eq:aggwithkin}, we calculate the coordinates of $\vec{p}'_i$ using
%   \eqref{eq:diffdrive2}:
%   \begin{equation*}
%     \vec{p}'_i = \begin{bmatrix}
%       -\delta + R\sin(\omega\Delta t)\\
%       R - R\cos(\omega\Delta t)\\
%     \end{bmatrix}
%   \end{equation*}
%   and calculate
%   \begin{equation*}
%     R = \frac{l}{2} \frac{1 + \sfrac{1}{3}}{1 - \sfrac{1}{3}} = l.
%   \end{equation*}
%   We now rewrite \eqref{eq:generic_agg} as
%   \begin{equation*}
%     \sqrt{(-\delta+l\sin(\omega\Delta t))^2 + (l - l\cos(\omega\Delta t))^2}\le\delta
%   \end{equation*}
%   For this inequality to hold, we need
%   \begin{align}
%     (-\delta+l\sin(\omega\Delta t))^2 + (l - l\cos(\omega\Delta t))^2 &\ge 0\label{eq:cond1}\tag{I1}\\
%     \delta &\ge 0\label{eq:cond2}\tag{I2}\\
%     (-\delta+l\sin(\omega\Delta t))^2 + (l - l\cos(\omega\Delta t))^2 &\le \delta^2.\label{eq:cond3}\tag{I3}
%   \end{align}
%   Inequality~\eqref{eq:cond2} is trivially true. Inequality~\eqref{eq:cond3} expands to
%   \begin{equation*}
%     l - \delta\sin(\omega\Delta t) - l\cos(\omega\Delta t) \le 0
%   \end{equation*}
%   and, since sine and cosine are bound in $[\,-1,1\,]$, we replace them with 1
%   and impose the more stringent (but mathematically simpler) condition
%   \begin{equation*}
%     l - \delta - l\le 0 \Rightarrow \delta \ge 0
%   \end{equation*}
%   which is, again, trivially true. Inequality~\eqref{eq:cond1} expands to
%   \begin{equation*}
%     \delta^2 + 2l - 2\delta l \sin(\omega\Delta t)-2 l^2 \cos(\omega\Delta t) \ge 0
%   \end{equation*}
%   and, similarly to what discussed for \eqref{eq:cond3}, we replace the
%   trigonometric functions with 1 and obtain the more stringent condition
%   \begin{equation*}
%     \delta^2-2\delta l + 2l -2l^2 \ge 0.
%   \end{equation*}
%   This inequality is quadratic in $\delta$ and it is satisfied if
%   $\delta \ge l + \sqrt{3l^2-2l}$.
  


  
%   which expands to
%   \begin{equation*}
%     \sqrt{\delta^2+2R^2-2\delta R\sin(\omega\Delta t)-2R^2\cos(\omega\Delta t)}\le\delta
%   \end{equation*}




  
%   Use the differential drive forward kinematics model to determine the coordinates of $p'_i$.
%   \begin{align} \label{eq:kin_theta_and_r}
%     \theta_1 &= \Delta t\omega = \Delta t \frac{v_{r_1} - v_{l_1}}{W} = \Delta t \frac{0.2 - 0.06667}{W} = \frac{2\Delta t}{15W} \\
%     R_1 &= \frac{W}{2}\bigg(\frac{v_{r_1} + v_{l_1}}{v_{r_1} - v_{l_1}}\bigg) = \frac{W}{2}\bigg(\frac{0.2 + 0.06667}{0.2 - 0.06667}\bigg) = W
%   \end{align}

%   We can define the coordinates of $p_i$, $p_j$, and $p'_i$.
  
%   \begin{align} \label{eq:kin_coordinates}
%     p_i &= \begin{bmatrix}-\delta \\ 0\end{bmatrix} \\
%     p_j &= \begin{bmatrix}0 \\ 0\end{bmatrix} \\
%     p'_i &= \begin{bmatrix}-\delta+R_1\sin(\theta_1) \\ R_1-R_1\cos(\theta_1)\end{bmatrix}
%   \end{align}
  
%   We also define the minimum possible $\delta$, which is acheived when the robots and tangent.
  
%   \begin{tikzpicture} [scale=0.5]
%     \draw (0,0) circle (1);
%     \filldraw (0,0) circle (0.1);
%     \node at (0.15,-0.6) {$r$};
%     \filldraw (2.6457,-3) circle (0.1);
%     \draw (2.6457,-3) circle (3);
%     \node at (1.9,-1.5) {$r_j$};
%     \draw (2.6457,0) -- (2.6457,-3);
%     \filldraw (.66,-.74) circle (0.1);
%     \draw (0,0) -- (2.6457,-3);
%     \draw (0,0) -- (2.6457,0);
%     \node at (1.7,.5) {$\delta_{\text{min}}$};
%   \end{tikzpicture}
%   \begin{align} \label{eq:min_delta}
%     \delta_{\text{min}} = \sqrt{(r + r_j)^2 - (r_j)^2} = \sqrt{r^2 + 2rr_j + r_j^2 - r_j^2} = \sqrt{r^2+2rr_j}
%   \end{align}
  
  
%   Show that $\lVert p'_i - p_j\rVert < \lVert p_i - p_j\rVert$ (Equation \eqref{eq:generic_agg}) for all $\delta > \sqrt{r^2+2rr_j}$.
  
%   \begin{align*}
%     \lVert p'_i - p_j \rVert &< \lVert p_i - p_j \rVert \\
%     \sqrt{(p'_{ix} - p_{jx})^2 + (p'_{iy} - p_{jy})^2} &< \sqrt{(p_{ix} - p_{jx})^2 + (p_{iy} - p_{jy})^2} \\
%     \sqrt{(-\delta+R_1\sin(\theta_1)-0)^2 + (R_1-R_1\cos(\theta_1-0)^2} &< \sqrt{(-\delta-0)^2 + (0-0)^2} \\
%     \sqrt{\delta^2-2\delta R_1\sin(\theta_1) + R_1^2\sin(\theta_1)^2 + R_1^2-2R_1^2\cos(\theta_1)+R_1^2\cos(\theta_1)^2} &< \delta \\
%     \intertext{Apply $\sin^2+\cos^2=1$}
%     \sqrt{\delta^2-2\delta R_1\sin(\theta_1) + 2R_1^2-2R_1^2\cos(\theta_1)} &< \delta \\
%     \delta^2-2\delta R_1\sin(\theta_1) + 2R_1^2-2R_1^2\cos(\theta_1) &< \delta^2 \\
%     -\cancel{2}\delta \cancel{R_1}\sin(\theta_1) - \cancel{2}R_1^{\cancel{2}}\cos(\theta_1) + \cancel{2}R_1^{\cancel{2}} &< 0 \\
%     -\delta \sin(\theta_1) - R_1\cos(\theta_1) + R_1 &< 0 \\
%     \intertext{We assume $\theta_1\in(0,\sfrac{\pi}{2})$, so if the above condition holds for the smallest $\delta=\delta_{\text{min}}$, it holds for greater $\delta$.}
%     -\sqrt{r^2+2rr_j}\sin\bigg(\frac{2\Delta t}{15W}\bigg) - W\cos\bigg(\frac{2\Delta t}{15W}\bigg) + W &< 0
%   \end{align*}
% \end{proof}









%     \begin{equation} \label{eq:kin_agg_result}
%       -\sqrt{r^2+2rr_j}\sin\bigg(\frac{2\Delta t}{15W}\bigg) - W\cos\bigg(\frac{2\Delta t}{15W}\bigg) + W < 0
%     \end{equation}

%     One can substitute in the parameters of their robot into this equation, and if the condition holds true then the behavior described here is guaranteed.

%     \subsection{Aggregation with Non-Kin}
%     \label{sec:analysisnonkin}
%     \begin{figure}[t!]
%       \centering
%       \begin{tikzpicture}[scale=25.0]
%         \draw[->] (0.15,0) -- (0.23,0);
%         \node at (0.22,.01) {x};
%         \draw[->] (0.15,0) -- (0.15,0.07);
%         \node at (.14,0.07) {y};

%         % c_i
%         \filldraw (0,-0.025) circle (.002);
%         \draw[blue, dashed] (0,-0.025) circle (0.025);

%         % p_i
%         \filldraw (0,-0.0) circle (.002);
%         \draw[blue] (0,-.0) circle (0.035);
%         \node at (-0.05,-.017) {$R_\text{nonkin}$};
%         \draw (-0.002,0.011) -- (0,.004);
%         \node at (-0.002,0.014) {$p_i$};

%         % delta
%         \draw[blue] (0,.0) -- (.15,.0);
%         \node at (0.08, 0.008) {$\delta$};

%         % p'_i
%         \filldraw (0.01,-0.003) circle (.002);
%         \draw[blue] (0.01,-0.003) circle (0.035);
%         \draw[dashed] (0,-0.025) -- (0.01,-0.003);
%         \draw[dashed] (0,0.0)-- (0,-0.025);
%         \draw (0.014, -0.003) -- (.04,-0.012);
%         \node at (0.055,-.010) {$p'_i$};

%         % p_j
%         \draw[dashed, red] (0.15, -0.035) circle (0.035);
%         \filldraw (0.15, 0.0) circle (.002);
%         \node at (0.159, 0.010) {$p_j$};

%         % theta
%         \draw (0,-.01) arc [radius=.025, start angle=90, end angle=75];
%         \node at (.035,-.045) {$\theta_\text{nonkin}$};
%         \draw (.002, -.015) -- (.027,-.042);

%       \end{tikzpicture}
%       \caption{A diagram depicting the geometry of a robot (in blue) aggregating
%         to a non-kin robot (in red).  The configuration of a robot aggregating
%         to another kin. $R_{\text{nonkin}}$ is the radius of the robots path
%         around the instantaneous radius of curvature.}
%       \label{fig:non_kin_aggregation}
%     \end{figure}

%     This scenario and proof follows the same pattern as with kin, but the resulting condition is slightly different. We can again expand Equation \eqref{eq:generic_agg}, this time with different coordinates for $p'_i$. The full derivation can be found in Theorem \ref{thm:aggregation_with_non_kin}, and the result is shown in Equation \eqref{eq:non_kin_agg_result}.

%     \begin{equation} \label{eq:non_kin_agg_result}
%       -\sqrt{r^2+2rr_j}\sin\bigg(\frac{2\Delta t}{10W}\bigg) - \frac{W}{2}\cos\bigg(\frac{2\Delta t}{10W}\bigg) + \frac{W}{2} < 0
%     \end{equation}

%     \subsection{Segregation}

%     So far all of the behaviors we have discussed are actually just aggregation behaviors. Here we partially explain why segregation occurs by showing that kin robots aggregate faster than the non-kin robots. To show that non-kin aggregate more slowly than kin, we show that the displacement during their kin step (the arc left with speeds $0.06667, 0.2$) is greater than the displacement during their non-kin step (with speeds $0.2, 0.0$). This proof can be found with Theorem \ref{thm:seg}. Note that we only consider the magnitude of the step, not the direction, so in theory the longer kin step could aggregate less than the shorter non-kin step, but this partially justifies why kin aggregate faster then non-kin.
    
  % \subsection{Application to Real Swarm Robots}

  %   The above conditions do not hold true for all scenarios (such as those with large $\Delta t$), but we show that they do hold true for a number of popular robots in Table \ref{table:robots}.

  %   \begin{savenotes}
  %   \begin{table}
  %     \centering
  %     \caption{Aggregation is guaranteed for many differential drive swarm robots. We used $\Delta t=0.1$ here, and assume $r_j=r$}
  %     \begin{tabular}{|c|c|c|c|c|c|} \hline
  %       Robot & $r$ (m) & $W$ (m) & Eq \eqref{eq:kin_agg_result}& Eq \eqref{eq:non_kin_agg_result} & Guaranteed \\ \hline
  %       foot-bot\footnote{\href{https://github.com/ilpincy/argos3/blob/master/src/plugins/robots/foot-bot/simulator/footbot_entity.cpp}{ARGoS file footbot\_entity.cpp}} &
  %           0.085 & 0.14 & -0.013 & -0.020 & Yes \\ \hline
  %       Khephera IV\footnote{Khephera IV User Manual, page 66.} &
  %           0.07 & 0.1054 & -0.014 & -0.021 & Yes \\ \hline
  %       E-Puck 2\footnote{\href{http://projects.gctronic.com/epuck2/e-puck2-flyer.pdf}{http://projects.gctronic.com/epuck2/e-puck2-flyer.pdf}} &
  %           0.035 & 0.053 & -0.013 & -0.020 & Yes \\ \hline
  %       Kilobot\footnote{\href{https://www.k-team.com/mobile-robotics-products/kilobot/specifications}{https://www.k-team.com/mobile-robotics-products/kilobot/specifications}} &
  %           0.0165 & 0.030\footnote{only approximate} & -0.009 & -0.014 & Yes \\ \hline
  %     \end{tabular}
  %     \label{table:robots}
  %   \end{table}
  %   \end{savenotes}

  %   Ultimately, we can use these geometric proof to make useful assertions about the behavior of an individual in our swarm and of the swarm as a whole. While we have not shown that segregation is guaranteed in all cases, this may serve as a building block for more general claims.

\section{Experimental Results}

% \subsection{Comparing Cost Functions} \label{section:evaluating_cost_functions}

% We ran grid search using both of our cost functions.

\subsection{Scalability Study} \label{section:scalability}

In this experiment we investigate how the segregation behavior scales with the
number of classes and the number of robots in the environment. We varied the
number of classes from 1 to 25 and ran 100 trials with robots uniformly randomly
distributed.

\myparagraph{Fixed number of robots per class}
We studied the case in which every class has 10 robots. The results of this are
plotted in Figure \ref{fig:num_classes_10}. We observe that the cost increases
with the number of classes. This occurs because, as the number of classes
increases, the density of the robots increases too. Hence, line-of-sight
occlusions between robots are more likely, navigation is more difficult, and the
clusters do not have a chance to coalesce.

\myparagraph{Fixed total number of robots}
We considered the scenario in which a fixed number of robots is split into an
increasing number of classes. We set the number of robots to 100, so with 25
classes 4 robots were still assigned to each class. As reported in
Fig.~\ref{fig:num_classes_100}, the cost is high for small numbers of classes
but its value decreases fast and eventually oscillates lightly. The initial high
cost is due to the fact that, with 100 robots to divided among few classes, it
is difficult for every robot to join the same cluster. The clusters, instead,
tend to form large islands of kins. As the number of classes increases, we
conjecture that the oscillations are an artifact of the random initial
conditions of each experiment.

\begin{figure}[t]
  \centering
  \includegraphics[width=1\linewidth]{./images/num_classes_vs_cost_100_robots.png}
  \caption{The average cost with 100 robots divided into $N$ classes.}
  \label{fig:num_classes_100}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=1\linewidth]{./images/num_classes_vs_cost_10_per_class.png}
  \caption{The average cost with $N$ classes, 10 robots per class.}
  \label{fig:num_classes_10}
\end{figure}

\subsection{The Effect of Implementation Details of the sensor} \label{section:sensor_impl}

We observed that the implementation details of the sensor have a significant
effect on the behavior of the controller.

Initially, our method for determining sensor state from the simulated
range-and-bearing system was to consider all the robots within some small angle
in front of the robot and pick the closest one. This is very similar to what
would be provided by a real-world camera that uses colored skirts on each robot
and picks the largest blob as the robot to be detected. This sensor
implementation works well and was used in the grid search experiments. However,
we found later that, if the robots instead always prefer to react to kin over
non-kin, larger rings form more quickly and robustly. For example, if there are
two robots within the field of view of a robot's sensor and the non-kin robot is
closer, the robot would ignore it and execute the $S=1$ logic, which drives the
robot towards the farther kin robot. Exploring exactly which of the various
implementation details have what effect on cost is left for future work.

\subsection{The Effect of the Beam Angle} \label{sec:aperture_angle}

On a real robot, there must be some finite beam angle to the theoretically
line-of-sight sensor. We ran 100 trials in simulation with uniformly random
initial distributions of 40 robots with various beam
angles. Fig.~\ref{fig:beam_angle} shows the results, along with a diagram
showing how we define beam angle. The best beam angle we tested was \ang{15},
and angles smaller or larger became progressively worse. We found that at lower
beam angles, it was possible for a robot to become stuck in groups of two or
three, and the robots spent all their time looking at each other instead of
peeking around them to find kin. At larger angles, we suspect the behavior fails
because larger beam angles cause the rings to enlarge faster, which in turn
causes the rings to be so large that they are not considered a cluster anymore
by our cost function.

\begin{figure}[t]
  \centering
  \includegraphics[width=1\linewidth]{./images/beam_angle.png}
  \begin{tikzpicture}
    \draw (0,0) circle (0.75);
    \draw (0,0) -- (5,0.7);
    \draw[dashed] (0,0) -- (5,0);
    \draw (0,0) -- (5,-0.7);
    \draw (4,0) arc [radius=4, start angle=0, end angle=8];
    \node at (4.25,0.25) {$\beta$};
  \end{tikzpicture}
  \caption{A \ang{15} degree half beam angle is best for segregation. Lower cost is better.}
  \label{fig:beam_angle}
\end{figure}

\subsection{The Effect of Beam Length} \label{section:beam_range}

We consider what happens if the theoretically infinite-range sensor has finite
range. We use \ang{15} half beam angle and the same experimental setup as with
the beam angle experiments. We consider the maximum range of the sensor as the
diagonal length of the square in which the robot are initially distributed. In
all our experiments, this square was \SI{5}{\meter} on each side, so we consider
a range of \SI{7.07}{\meter} to be effectively unlimited. We report the costs
for beam ranges as a fraction of this maximum range. As shown in
Figure~\ref{fig:beam_range}, a beam range of 35\% of the theoretical maximum
performs just as well as an infinite sensor. Below this, the performance
degrades. However, even a beam range of 7\% of the maximum is more effective
than zero range at segregation.

\begin{figure}[t]
  \centering
  \includegraphics[width=1\linewidth]{./images/beam_length.png}
  \caption{Segregation is robust to small sensor beam ranges. The blue bar
    indicates the worst (highest) attainable cost in which all robots are
    isolated from any kin.}
  \label{fig:beam_range}
\end{figure}

\section{Conclusion}

In this paper, we show how oblivious robots are capable of $N$-class
segregation. We use a simple controller design consisting of a 6-tuple. This
controller is invariant to the number of classes, so any given controller can
work for any number of classes. We performed a grid search to learn about the
full parameter space, and we investigated the effect of sensor implementation
details and the number of robots and classes on performance. Our findings
indicate that robust segregation in reality is possible, although not
guaranteed.

\bibliography{RBE595.bib}
\bibliographystyle{unsrt}

% \onecolumn
% \appendix
% \section{Appendix}



%   \begin{theorem} \label{thm:aggregation_with_non_kin}
%     An isolated robot will aggregate to a non kin entity.
%   \end{theorem}
%   \begin{proof}
%     \begin{align}
%       \begin{split} \label{eq:non_kin_theta_and_r}
%         \theta_2 &= \Delta t\omega = \Delta t \frac{v_{r_2} - v_{l_2}}{W} = \Delta t \frac{0.2 - 0.0}{W} = \frac{2\Delta t}{10W} \\
%         R_2 &= \frac{W}{2}\bigg(\frac{v_{r_2} + v_{l_2}}{v_{r_2} - v_{l_2}}\bigg) = \frac{W}{2}\bigg(\frac{0.2 + 0.0}{0.2 - 0.0}\bigg) = \frac{W}{2}
%       \end{split}
%     \end{align}

%     We can define the coordinates of the new $p'_i$.

%     \begin{align} \label{eq:non_kin_coordinates}
%       p'_i = \begin{bmatrix}-\delta+R_2\sin(\theta_2) \\ -R_2+R_2\cos(\theta_2)\end{bmatrix}
%     \end{align}

%     Show that $\lVert p'_i - p_j\rVert < \lVert p_i - p_j\rVert$ for all $\delta > \sqrt{r^2+2rr_j}$. This follows the same steps as the Theorem \ref{thm:aggregation_with_kin}.

%     \begin{align*}
%       \lVert p'_i - p_j \rVert &< \lVert p_i - p_j \rVert \\
%       \sqrt{(-\delta+R_2\sin(\theta_2)-0)^2 + (-R_2+R_2\cos(\theta_2-0)^2} &< \sqrt{(-\delta-0)^2 + (0-0)^2} \\
%       \sqrt{\delta^2-2\delta R_2\sin(\theta_2) + R_2^2\sin(\theta_2)^2 + R_2^2-2R_2^2\cos(\theta_2)+R_2^2\cos(\theta_2)^2} &< \delta \\
%       \sqrt{\delta^2-2\delta R_2\sin(\theta_2) + 2R_2^2-2R_2^2\cos(\theta_2)} &< \delta \\
%       -2\delta R_2\sin(\theta_2) - 2R_2^2\cos(\theta_2) + 2R_2^2 &< 0 \\
%       -\delta \sin(\theta_2) - R_2\cos(\theta_2) + R_2 &< 0 \\
%       \intertext{We assume $\theta_2\in(0,\sfrac{\pi}{2})$, so if the above condition holds for the smallest $\delta=\delta_{\text{min}}$, it holds for greater $\delta$.}
%       -\sqrt{r^2+2rr_j}\sin\bigg(\frac{2\Delta t}{10W}\bigg) - \frac{W}{2}\cos\bigg(\frac{2\Delta t}{10W}\bigg) + \frac{W}{2} &< 0
%     \end{align*}
%   \end{proof}

%   \begin{theorem} \label{thm:seg}
%     The distance moved in the kin step is always greater than the distance moved in the non-kin step.
%   \end{theorem}
%   \begin{proof}
%     We compare the arc lengths derived from the wheels speeds.
%     \begin{align*}
%       \theta_1 R_1 &> \theta_2 R_2 \\
%       \frac{2\cancel{\Delta t}}{15\cancel{W}} \cancel{W} &> \frac{\cancel{2}\cancel{\Delta t}}{10\cancel{W}} \frac{\cancel{W}}{\cancel{2}} \\
%       \frac{2}{15} &> \frac{1}{10} \\
%     \end{align*}
%   \end{proof}

%   \subsection{Grid Search Images} \label{section:grid_search_images}


%     \begin{align*}
%     \lVert p'_i - p_j \rVert &< \lVert p_i - p_j \rVert \\
%     \sqrt{(p'_{ix} - p_{jx})^2 + (p'_{iy} - p_{jy})^2} &< \sqrt{(p_{ix} - p_{jx})^2 + (p_{iy} - p_{jy})^2} \\
%     \sqrt{(-\delta+R_1\sin(\theta_1)-0)^2 + (R_1-R_1\cos(\theta_1-0)^2} &< \sqrt{(-\delta-0)^2 + (0-0)^2} \\
%     \sqrt{\delta^2-2\delta R_1\sin(\theta_1) + R_1^2\sin(\theta_1)^2 + R_1^2-2R_1^2\cos(\theta_1)+R_1^2\cos(\theta_1)^2} &< \delta \\
%     \intertext{Apply $\sin^2+\cos^2=1$}
%     \sqrt{\delta^2-2\delta R_1\sin(\theta_1) + 2R_1^2-2R_1^2\cos(\theta_1)} &< \delta \\
%     \delta^2-2\delta R_1\sin(\theta_1) + 2R_1^2-2R_1^2\cos(\theta_1) &< \delta^2 \\
%     -\cancel{2}\delta \cancel{R_1}\sin(\theta_1) - \cancel{2}R_1^{\cancel{2}}\cos(\theta_1) + \cancel{2}R_1^{\cancel{2}} &< 0 \\
%     -\delta \sin(\theta_1) - R_1\cos(\theta_1) + R_1 &< 0 \\
%     \intertext{We assume $\theta_1\in(0,\sfrac{\pi}{2})$, so if the above condition holds for the smallest $\delta=\delta_{\text{min}}$, it holds for greater $\delta$.}
%     -\sqrt{r^2+2rr_j}\sin\bigg(\frac{2\Delta t}{15W}\bigg) - W\cos\bigg(\frac{2\Delta t}{15W}\bigg) + W &< 0
%   \end{align*}


\end{document}
